

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Matter Intermittently Connected Devices (ICD) &mdash; Matter 2.3.1-1.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/custom_styles.css" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
      <script src="../_static/jquery.js"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
      <script src="../_static/doctools.js"></script>
      <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Creating Gecko Bootloader for Use in Matter OTA Software Update" href="OTA_BOOTLOADER.html" />
    <link rel="prev" title="Matter Security" href="SECURITY.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #3b82f6" >

          
          
          <a href="../index.html" class="icon icon-home">
            Matter
              <img src="../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../OVERVIEW.html">User's Guide Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../NEW_FEATURES.html">Matter New Features</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../nav_1_overview.html">Matter Overview</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="FUNDAMENTALS_INTRO.html">Introduction to Matter</a></li>
<li class="toctree-l2"><a class="reference internal" href="FUNDAMENTALS_DATA_MODEL.html">The Matter Data Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="FUNDAMENTALS_INTERACTION_MODEL.html">The Matter Interaction Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="COMMISSIONING.html">Commissioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="SECURITY.html">Matter Security</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Matter Intermittently Connected Devices (ICD)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#icd-configurations">ICD Configurations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#icd-device-types">ICD Device Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="OTA_BOOTLOADER.html">Creating Gecko Bootloader for Use in Matter OTA Software Update</a></li>
<li class="toctree-l2"><a class="reference internal" href="OTA_SOFTWARE_UPDATE.html">Matter Software Update with Silicon Labs Example Applications</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../nav_2_prereq.html">Matter Development Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nav_4_thread.html">Matter Over Thread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nav_5_wifi.html">Matter Over Wi-Fi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nav_7_prod_guide.html">Matter Production Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../unify/index.html">Unify Matter Solutions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nav_3_general.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nav_6_faq.html">FAQ</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #3b82f6" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Matter</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../nav_1_overview.html">Matter Overview</a></li>
      <li class="breadcrumb-item active">Matter Intermittently Connected Devices (ICD)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/general/MATTER_ICD.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="matter-intermittently-connected-devices-icd">
<h1>Matter Intermittently Connected Devices (ICD)<a class="headerlink" href="#matter-intermittently-connected-devices-icd" title="Permalink to this heading"></a></h1>
<p>Matter introduces the concept of Intermittently Connected Devices (ICD) in the SDK and in the specification.
An Intermittently Connected Device is the Matter representation of a device that is not always reachable.
This covers battery-powered devices that disable their underlying hardware when in a low-power mode or devices that can be disconnected from the network, like a phone app.</p>
<p>This page focuses on features designed to improve the performance and reliability of battery-powered devices and their different configuration options.</p>
<section id="icd-configurations">
<h2>ICD Configurations<a class="headerlink" href="#icd-configurations" title="Permalink to this heading"></a></h2>
<p>The ICD feature-set offers two types of configurations : cluster configurations and subscription configurations.
The cluster configurations are exposed through the ICD Manager Cluster interface.
The subscription configurations are exposed through build arguments and public APIs of the Matter SDK.</p>
<section id="icd-management-cluster">
<h3>ICD Management Cluster<a class="headerlink" href="#icd-management-cluster" title="Permalink to this heading"></a></h3>
<p>The ICD Management Cluster enables configuration of the ICD’s behavior.
It is required for an ICD to have this cluster enabled on endpoint 0 to be certifiable.</p>
<section id="configuration-attributes">
<h4>Configuration Attributes<a class="headerlink" href="#configuration-attributes" title="Permalink to this heading"></a></h4>
<p>The ICD Management Cluster exposes three configuration attributes.
These configurations are independent from the underlying transport configurations.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Constraints</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IdleModeInterval</p></td>
<td><p>uint32</p></td>
<td><p>1 to 64800</p></td>
<td><p>Maximum interval in seconds or milliseconds the server can stay in idle mode</p></td>
</tr>
<tr class="row-odd"><td><p>ActiveModeInterval</p></td>
<td><p>uint32</p></td>
<td><p>all</p></td>
<td><p>minimum interval in milliseconds the server will stay in active mode</p></td>
</tr>
<tr class="row-even"><td><p>ActiveModeThreshold</p></td>
<td><p>uint16</p></td>
<td><p>desc</p></td>
<td><p>minimum amount of time in milliseconds the server typically will stay active after network activity when in active mode</p></td>
</tr>
</tbody>
</table>
<p>These configurations can be changed two different ways.</p>
<p>To change them within a build command</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>./scripts/examples/gn_silabs_example.sh<span class="w"> </span>./examples/light-switch-app/silabs<span class="w"> </span>./out/light-switch-app_ICD<span class="w"> </span>BRD4187C<span class="w"> </span>--icd<span class="w"> </span><span class="nv">sl_idle_mode_interval_ms</span><span class="o">=</span><span class="m">5000</span><span class="w"> </span><span class="nv">sl_active_mode_interval_ms</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">sl_active_mode_threshold_ms</span><span class="o">=</span><span class="m">500</span>
</pre></div>
</div>
<p>These options can also be change by setting them to a default value in the projects openthread.gni file. See examples/lock-app/silabs/openthread.gni for an example on how they can be configured.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ICD Matter Configuration flags</span>
<span class="n">sl_idle_mode_interval_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">600</span><span class="w">       </span><span class="c1">//10min Idle Mode Interval</span>
<span class="n">sl_active_mode_interval_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000</span><span class="w">  </span><span class="c1">//10s Active Mode Interval</span>
<span class="n">sl_active_mode_threshold_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="w">  </span><span class="c1">//1s Active Mode Threshold</span>
</pre></div>
</div>
<p>The second way of changing the configuration is to set these defines in the projects ChipProjectConfig.h.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @def CHIP_CONFIG_ICD_IDLE_MODE_INTERVAL_SEC</span>
<span class="cm"> *</span>
<span class="cm"> * @brief Default value for the ICD Management cluster IdleModeInterval attribute, in seconds</span>
<span class="cm"> */</span>
<span class="cp">#define CHIP_CONFIG_ICD_IDLE_MODE_INTERVAL_SEC 5</span>


<span class="cm">/**</span>
<span class="cm"> * @def CHIP_CONFIG_ICD_ACTIVE_MODE_INTERVAL_MS</span>
<span class="cm"> *</span>
<span class="cm"> * @brief Default value for the ICD Management cluster ActiveModeInterval attribute, in milliseconds</span>
<span class="cm"> */</span>
<span class="cp">#define CHIP_CONFIG_ICD_ACTIVE_MODE_INTERVAL_MS 0</span>

<span class="cm">/**</span>
<span class="cm"> * @def CHIP_CONFIG_ICD_ACTIVE_MODE_THRESHOLD_MS</span>
<span class="cm"> *</span>
<span class="cm"> * @brief Default value for the ICD Management cluster ActiveModeThreshold attribute, in milliseconds</span>
<span class="cm"> */</span>
<span class="cp">#define CHIP_CONFIG_ICD_ACTIVE_MODE_THRESHOLD_MS 500</span>
</pre></div>
</div>
<p>Using the build arguments either in the build command or in the .gni file is the preferred method.</p>
</section>
<section id="icd-check-in-protocol-use-case">
<h4>ICD Check-In Protocol Use-Case<a class="headerlink" href="#icd-check-in-protocol-use-case" title="Permalink to this heading"></a></h4>
<p>The ICD Check-In Protocol use case is used by ICDs to maintain a known relationship in case subscriptions with clients are lost.
This includes how a client shares a Check-In token (symmetric key) with the ICD, when Check-In messages are sent and how the Check-In Protocol requirements are respected.</p>
<p>The Check-In Protocol is a fail-safe mechanism which allows an ICD to notify a registered client that it is available for communication when all subscriptions between the client and ICD are lost.
A subscription can be lost for several reasons, such as:</p>
<ul class="simple">
<li><p>The ICD might not have full RAM retention when it is in an idle state.</p></li>
<li><p>When the ICD is powered off to change the battery.</p></li>
<li><p>Power or network outage causing the connection between the client and the ICD to be interrupted.</p></li>
<li><p>The client is unavailable for any reason (e.g. during a software update or hosted on a mobile device that is sometimes out-of-home).</p></li>
</ul>
<p>The Check-In message is sessionless and relies on a shared secret that has been given to the ICD during the registration of the client using the ICD Management cluster.
For more information on the ICD Check-In Protocol use-case, see the associated specification section.</p>
</section>
<section id="user-active-mode-trigger">
<h4>User Active Mode Trigger<a class="headerlink" href="#user-active-mode-trigger" title="Permalink to this heading"></a></h4>
<p>Since ICDs are not immediately responsive, they require a means to render them available for communication within user initiated use cases.
Some of the user initiated use cases are:</p>
<ul class="simple">
<li><p>Opening a new commissioning window to add another administrator.</p></li>
<li><p>Reconfiguration of an existing fabric (e.g. IPKs, NOC rotation, ACL changes).</p></li>
<li><p>Reconfiguration of cluster functionality (e.g. ICD Management, Bindings, Groups, Scenes).</p></li>
<li><p>Removal of a device from a fabric.</p></li>
<li><p>Changes to the device’s settings.</p></li>
</ul>
<p>To enable these user initiated use cases, ICDs need to provide a way for a user to put them in active mode and render them responsive.
The User Active Mode Trigger feature in the ICD Management cluster indicates whether a particular device implements an active mode trigger.</p>
</section>
</section>
<section id="subscription-configurations">
<h3>Subscription Configurations<a class="headerlink" href="#subscription-configurations" title="Permalink to this heading"></a></h3>
<section id="subscription-maximum-interval-negotiation">
<h4>Subscription Maximum Interval Negotiation<a class="headerlink" href="#subscription-maximum-interval-negotiation" title="Permalink to this heading"></a></h4>
<p>The subscription mechanism is used by ecosystems and controllers to receive attribute change updates and liveness checks.
The maximum interval of a subscription request is what defines the frequency at which a device will send a liveness check if there are no attribute changes.</p>
<p>Within the subscription request / response model, a device has the opportunity to decide the maximum interval at which it will send its liveness check (Empty Report Update). The device can set a maximum interval within this range if and only if it is an ICD:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>MinIntervalRequested<span class="w"> </span>≤<span class="w"> </span>MaxInterval<span class="w"> </span>≤<span class="w"> </span>MAX<span class="o">(</span>IdleModeInterval,<span class="w"> </span>MaxIntervalRequested<span class="o">)</span>
</pre></div>
</div>
<p>The following table shows the subscribe response fields.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Action Field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SubscriptionId</p></td>
<td><p>uint32</p></td>
<td><p>identifies the subscription</p></td>
</tr>
<tr class="row-odd"><td><p>MaxInterval</p></td>
<td><p>uint16</p></td>
<td><p>the final maximum interval for the subscription in seconds</p></td>
</tr>
</tbody>
</table>
<p>The Matter SDK provides a default implementation that allows an ICD to negotiate its MaxInterval.
The goal of the algorithm is to set the MaxInterval to the IdleModeInterval.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#if CHIP_CONFIG_ENABLE_ICD_SERVER</span>

<span class="w">    </span><span class="c1">// Default behavior for ICDs where the wanted MaxInterval for a subscription is the IdleModeInterval</span>
<span class="w">    </span><span class="c1">// defined in the ICD Management Cluster.</span>
<span class="w">    </span><span class="c1">// Behavior can be changed with the OnSubscriptionRequested function defined in the application callbacks</span>

<span class="w">    </span><span class="c1">// Default Behavior Steps :</span>
<span class="w">    </span><span class="c1">// If MinInterval &gt; IdleModeInterval, try to set the MaxInterval to the first interval of IdleModeIntervals above the</span>
<span class="w">    </span><span class="c1">// MinInterval.</span>
<span class="w">    </span><span class="c1">// If the next interval is greater than the MaxIntervalCeiling, use the MaxIntervalCeiling.</span>
<span class="w">    </span><span class="c1">// Otherwise, use IdleModeInterval as MaxInterval</span>

<span class="w">    </span><span class="c1">// GetPublisherSelectedIntervalLimit() returns the IdleModeInterval if the device is an ICD</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">decidedMaxInterval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetPublisherSelectedIntervalLimit</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Check if the PublisherSelectedIntervalLimit is 0. If so, set decidedMaxInterval to MaxIntervalCeiling</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">decidedMaxInterval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">decidedMaxInterval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mMaxInterval</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If requestedMinInterval is greater than the IdleTimeInterval, select next active up time as max interval</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mMinIntervalFloorSeconds</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">decidedMaxInterval</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">ratio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mMinIntervalFloorSeconds</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">decidedMaxInterval</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mMinIntervalFloorSeconds</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">decidedMaxInterval</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ratio</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">decidedMaxInterval</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">ratio</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Verify that decidedMaxInterval is an acceptable value (overflow)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">decidedMaxInterval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">System</span><span class="o">::</span><span class="n">Clock</span><span class="o">::</span><span class="n">Seconds16</span><span class="o">::</span><span class="n">max</span><span class="p">().</span><span class="n">count</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">decidedMaxInterval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="o">::</span><span class="n">Clock</span><span class="o">::</span><span class="n">Seconds16</span><span class="o">::</span><span class="n">max</span><span class="p">().</span><span class="n">count</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Verify that the decidedMaxInterval respects MAX(GetPublisherSelectedIntervalLimit(), MaxIntervalCeiling)</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">maximumMaxInterval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">GetPublisherSelectedIntervalLimit</span><span class="p">(),</span><span class="w"> </span><span class="n">mMaxInterval</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">decidedMaxInterval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">maximumMaxInterval</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">decidedMaxInterval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maximumMaxInterval</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Set max interval of the subscription</span>
<span class="w">    </span><span class="n">mMaxInterval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">decidedMaxInterval</span><span class="p">);</span>

<span class="cp">#endif </span><span class="c1">// CHIP_CONFIG_ENABLE_ICD_SERVER</span>
</pre></div>
</div>
<p>If the default implementation does not fit within the use-case,
an implementation can override the default implementation.
The first step is to implement the <code class="docutils literal notranslate"><span class="pre">ApplicationCallback</span></code> class from the <code class="docutils literal notranslate"><span class="pre">ReadHandler.h</span></code> header.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * A callback used to interact with the application.</span>
<span class="cm"> */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplicationCallback</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">ApplicationCallback</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Called right after a SubscribeRequest has been parsed and processed. This notifies an interested application</span>
<span class="cm">     * of a subscription that is about to be established. It also provides an avenue for altering the parameters of the</span>
<span class="cm">     * subscription (specifically, the min/max negotiated intervals) or even outright rejecting the subscription for</span>
<span class="cm">     * application-specific reasons.</span>
<span class="cm">     *</span>
<span class="cm">     * TODO: Need a new IM status code to convey application-rejected subscribes. Currently, a Failure IM status code is sent</span>
<span class="cm">     * back to the subscriber, which isn&#39;t sufficient.</span>
<span class="cm">     *</span>
<span class="cm">     * To reject the subscription, a CHIP_ERROR code that is not equivalent to CHIP_NO_ERROR should be returned.</span>
<span class="cm">     *</span>
<span class="cm">     * More information about the set of paths associated with this subscription can be retrieved by calling the appropriate</span>
<span class="cm">     * Get* methods below.</span>
<span class="cm">     *</span>
<span class="cm">     * aReadHandler:            Reference to the ReadHandler associated with the subscription.</span>
<span class="cm">     * aSecureSession:          A reference to the underlying secure session associated with the subscription.</span>
<span class="cm">     *</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">CHIP_ERROR</span><span class="w"> </span><span class="nf">OnSubscriptionRequested</span><span class="p">(</span><span class="n">ReadHandler</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">aReadHandler</span><span class="p">,</span><span class="w"> </span><span class="n">Transport</span><span class="o">::</span><span class="n">SecureSession</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">aSecureSession</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">CHIP_NO_ERROR</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Called after a subscription has been fully established.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnSubscriptionEstablished</span><span class="p">(</span><span class="n">ReadHandler</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">aReadHandler</span><span class="p">){};</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Called right before a subscription is about to get terminated. This is only called on subscriptions that were terminated</span>
<span class="cm">     * after they had been fully established (and therefore had called OnSubscriptionEstablished).</span>
<span class="cm">     * OnSubscriptionEstablishment().</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnSubscriptionTerminated</span><span class="p">(</span><span class="n">ReadHandler</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">aReadHandler</span><span class="p">){};</span>
<span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>The second step is registering the callback object to the Interaction Model Engine.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Register ICD subscription callback to match subscription max intervals to its idle time interval</span>
<span class="n">chip</span><span class="o">::</span><span class="n">app</span><span class="o">::</span><span class="n">InteractionModelEngine</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">RegisterReadHandlerAppCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mICDSubscriptionHandler</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="persistent-subscriptions">
<h4>Persistent Subscriptions<a class="headerlink" href="#persistent-subscriptions" title="Permalink to this heading"></a></h4>
<p>Persistent subscriptions were added to Matter as a means to ensure that an ICD can re-establish its subscription and by extension its secure session to a subscriber in the event of a power cycle.
When a device accepts a subscription request, it will persist the subscription.
When the device reboots, it will try to re-establish its subscription with the subscriber.
If the subscription is torn down during normal operations or if the re-establishment fails,
the subscription will be deleted.</p>
<p>Persistent subscriptions are enabled by default on all Silicon Labs sample applications.</p>
</section>
<section id="subscription-timeout-resumption">
<h4>Subscription Timeout Resumption<a class="headerlink" href="#subscription-timeout-resumption" title="Permalink to this heading"></a></h4>
<p>Matter also provides a retry mechanism for devices to try to re-establish a lost subscription with a client. This feature should not be used on an ICD since it can significantly reduce battery life. This functionality can be disabled by adding</p>
<p><code class="docutils literal notranslate"><span class="pre">chip_subscription_timeout_resumption</span> <span class="pre">=</span> <span class="pre">false</span></code></p>
</section>
<section id="subscription-synchronization">
<h4>Subscription Synchronization<a class="headerlink" href="#subscription-synchronization" title="Permalink to this heading"></a></h4>
<p>To avoid forcing an ICD to become active multiple times, the Matter SDK allows an ICD to synchronize its subscription reporting and send all the reports at the same time. The mecansim syncrhonizes the maximum interval of the all subscription to only require the ICD to become active one. This functionality can be enabled by adding</p>
<p><code class="docutils literal notranslate"><span class="pre">sl_use_subscription_synching</span> <span class="pre">=</span> <span class="pre">true</span></code></p>
<p>For further details on Matter ICD’s operating on OpenThread, visit <a class="reference internal" href="../thread/OT_SLEEPY_END_DEVICE.html"><span class="std std-doc">Matter Intermittently Connected Devices over OpenThread</span></a>.
And for Matter ICD’s operating via WiFi, visit <a class="reference internal" href="../wifi/WIFI_SLEEPY_END_DEVICE.html"><span class="std std-doc">Matter Intermittently Connected Devices over WiFi</span></a>.</p>
</section>
</section>
</section>
<section id="icd-device-types">
<h2>ICD Device Types<a class="headerlink" href="#icd-device-types" title="Permalink to this heading"></a></h2>
<p>Matter introduces two types of ICDs.</p>
<ul class="simple">
<li><p>Short Idle Time ICDs</p></li>
<li><p>Long Idle Time ICDs</p></li>
</ul>
<section id="short-idle-time-icds">
<h3>Short Idle Time ICDs<a class="headerlink" href="#short-idle-time-icds" title="Permalink to this heading"></a></h3>
<p>Short Idle Time ICDs are battery powered devices that can always be reached by clients.
This means that their polling intervals are small enough to guarantee that a message sent from a client will be able to reach the ICD without any synchronization.
A door lock, for example, is typicaly a short idle time ICD because it needs to be able to receive commands from clients at any given time.
These devices are usually not the initiators in the communication flow.</p>
<section id="requirements">
<h4>Requirements<a class="headerlink" href="#requirements" title="Permalink to this heading"></a></h4>
<p>This section lists the requirements that Short Idle Time ICDs must respect to be certifiable.</p>
<ol class="arabic simple">
<li><p>The ICD Management Cluster must be present on the Root Endpoint (0) with mandatory attributes.</p></li>
<li><p>The transport slow poll configuration must be smaller or equal to 15s.
This requirement is not enforced in Matter 1.3 since LIT ICD are not certifiable.
Once LIT ICD officially launch, this will be a mandatory requirement.</p></li>
</ol>
<p>Support of the ICD Check-In Protocol use-case and the user active mode trigger is optional for SIT ICDs.</p>
</section>
<section id="configurations">
<h4>Configurations<a class="headerlink" href="#configurations" title="Permalink to this heading"></a></h4>
<p>These are recommended configurations based on the state of the current implementation of SIT ICDs.
The recommended configurations are likely to change with the Matter 1.4 release.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ICD Default configurations</span>
<span class="n">chip_enable_icd_server</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span>
<span class="n">chip_subscription_timeout_resumption</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span>
<span class="n">sl_use_subscription_synching</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span>

<span class="c1">// ICD Matter Configuration flags</span>
<span class="n">sl_idle_mode_duration_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">600</span><span class="w">  </span><span class="c1">// 10min Idle Mode Duration</span>
<span class="n">sl_active_mode_duration_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000</span><span class="w">  </span><span class="c1">// 10s Active Mode Duration</span>
<span class="n">sl_active_mode_threshold_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="w">  </span><span class="c1">// 1s Active Mode Threshold</span>

<span class="c1">// Openthread Configuration flags</span>
<span class="n">sl_ot_idle_interval_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5000</span><span class="w">  </span><span class="c1">// 5s Idle Intervals</span>
<span class="n">sl_ot_active_interval_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="w">  </span><span class="c1">// 500ms Active Intervals</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>Note</strong>: Wi-Fi polling configuration are dictated by the Access Point and cannot be changed at the Matter level.</p>
</div></blockquote>
</section>
</section>
<section id="long-idle-icds">
<h3>Long Idle ICDs<a class="headerlink" href="#long-idle-icds" title="Permalink to this heading"></a></h3>
<p>Long Idle Time ICDs are battery powered devices that require synchronization between the client and the ICD for communication to succeed.
A sensor device is an example of a device that are typically a long idle time ICD.</p>
<p>Long Idle Time ICDs are ready for integration in the Matter 1.3 release. The core feature-set for ICDs has been implemented through the <code class="docutils literal notranslate"><span class="pre">ICDManager</span></code>.
LIT ICDs should be certifiable with the Matter 1.4 release.
Splitting the two milestones in different releases is to allow more in depth interoperability testing to validate the proposed feature-set achieves it’s power consumption and usability goals.</p>
<section id="id1">
<h4>Requirements<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h4>
<p>This section lists the requirements that Long Idle Time ICDs must respect to be certifiable.</p>
<ol class="arabic simple">
<li><p>The ICD Management Cluster must be present on the Root Endpoint (0) with mandatory attributes.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">LITS</span></code> (Long Idle Time Support) feature map must be set to 1.
All required features, attributes and commands required by this feature map must also be present.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">CIP</span></code> (Check-In Protocol support) feature map must be set to 1.
All required attributes and commands required by this feature map must also be present.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">UAT</span></code> (User Active Mode Trigger support) feature map must be set to 1.
All required attributes and commands required by this feature map must also be present.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">ActiveModeThreshold</span></code> cannot be lower than 5 seconds.</p></li>
</ol>
</section>
<section id="id2">
<h4>Configurations<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h4>
<p>These are recommended configurations based on the state of the current implementation of LIT ICDs.
The recommended configurations are likely to change with the Matter 1.4 release.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ICD Default configurations</span>
<span class="n">chip_enable_icd_server</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span>
<span class="n">chip_subscription_timeout_resumption</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span>
<span class="n">sl_use_subscription_synching</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span>
<span class="n">icd_enforce_sit_slow_poll_limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span>
<span class="n">chip_icd_report_on_active_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span>
<span class="n">chip_enable_icd_lit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span>

<span class="cp"># Openthread Configuration flags</span>
<span class="n">sl_ot_idle_interval_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3600000</span><span class="w">  </span><span class="c1">// 60mins Idle Polling Interval</span>
<span class="n">sl_ot_active_interval_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="w">  </span><span class="c1">// 1s Active Polling Interval</span>

<span class="cp"># ICD Matter Configuration flags</span>
<span class="n">sl_idle_mode_duration_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3600</span><span class="w">  </span><span class="c1">// 60min Idle Mode Duration</span>
<span class="n">sl_active_mode_duration_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">  </span><span class="c1">// 0 Active Mode Duration</span>
<span class="n">sl_active_mode_threshold_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5000</span><span class="w">  </span><span class="c1">// 5s Active Mode Threshold</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer>
    <hr/>
    <p>Copyright © 2025 Silicon Laboratories. All rights reserved.</p>
</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>